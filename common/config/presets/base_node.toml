########################################################################################################################
#                                                                                                                      #
#                                          Base Node Configuration Options                                             #
#                                                                                                                      #
########################################################################################################################

# If you are not running a Tari Base node, you can simply leave everything in this section commented out. Base nodes
# help maintain the security of the Tari token and are the surest way to preserve your privacy and be 100% sure that
# no-one is cheating you out of your money.

[base_node]
# The socket to expose for the gRPC base node server
grpc_address = "/ip4/127.0.0.1/tcp/18142"
# Maximum number of RandomX virtual machines to cache. For low spec machines, set this to 1
# max_randomx_vms = 5
# Exclude rangeproof verification. Setting this to true is not recommended for production use. Use at own risk
# bypass_range_proof_verification = false

# The maximum number of orphans that can be stored in the Orphan block pool. Default value is "720".
#orphan_storage_capacity = 720
# The size that the orphan pool will be allowed to grow before it is cleaned out, with threshold being tested every
# time before fetch and add blocks. Default value is "0", which indicates the orphan pool will not be cleaned out.
#orphan_db_clean_out_threshold = 0

# The pruning horizon that indicates how many full blocks without pruning must be kept by the base node. Default value
# is "0", which indicates an archival node without any pruning.
#pruning_horizon = 0

# Set to true to record all reorgs. Recorded reorgs can be viewed using the list-reorgs command.
track_reorgs = true

# The type of database backend to use. Currently supported options are "memory" and "lmdb". LMDB is recommnded for
# almost all use cases.
# db_type = "lmdb"

[base_node.lmdb]
db_init_size_mb = 1000
db_grow_size_mb = 500
db_resize_threshold_mb = 100

# Configuration options for testnet dibbler
[dibbler.base_node]


# db config defaults

# The amount of messages that will be permitted in the flood ban timespan of 100s (Default dibbler = 100000,
# default mainnet = 100000)
flood_ban_max_msg_count = 100_000

# The relative path to store persistent data
data_dir = "dibbler"

# This allowlist provides a method to force syncing from any known nodes you may choose, for example if you have a
# couple of nodes that you always want to have in sync.
# force_sync_peers = ["public_key1::address1", "public_key2::address2",... ]
force_sync_peers = [
    #my known peer 1
    #"public_key1::address1",
    #my known peer 2
    #"public_key1::address1",
]


#rpc_max_simultaneous_sessions = 100

[base_node.p2p]

[base_node.p2p.dht]
auto_join=true
database_url="base_node_dht.db"
# do we allow test addresses to be accepted like 127.0.0.1
allow_test_addresses = false

[base_node.p2p.dht.saf_config]


# Determines the method of syncing blocks when the node is lagging. If you are not struggling with syncing, then
# it is recommended to leave this setting as it. Available values are ViaBestChainMetadata and ViaRandomPeer.
#block_sync_strategy="ViaBestChainMetadata"

# Configure the maximum number of threads available for base node operation. These threads are spawned lazily, so a higher
# number is recommended.
# max_threads = 512

# The number of threads to spawn and keep active at all times. The default is the number of cores available on this node.
# core_threads = <number of cores>

# The node's publicly-accessible hostname. This is the host name that is advertised on the network so that
# peers can find you.
# _NOTE_: If using the `tor` transport type, public_address will be ignored and an onion address will be
# automatically configured
#public_address = "/ip4/172.2.3.4/tcp/18189"




# A path to the file that stores your node identity and secret key
base_node_identity_file = "config/base_node_id.json"

# -------------- Transport configuration --------------
# Use TCP to connect to the Tari network. This transport can only communicate with TCP/IP addresses, so peers with
# e.g. tor onion addresses will not be contactable.
#transport = "tcp"
# The address and port to listen for peer connections over TCP.
#tcp_listener_address = "/ip4/0.0.0.0/tcp/18189"
# Configures a tor proxy used to connect to onion addresses. All other traffic uses direct TCP connections.
# This setting is optional however, if it is not specified, this node will not be able to connect to nodes that
# only advertise an onion address.
#tcp_tor_socks_address = "/ip4/127.0.0.1/tcp/36050"
#tcp_tor_socks_auth = "none"

# Configures the node to run over a tor hidden service using the Tor proxy. This transport recognises ip/tcp,
# onion v2, onion v3 and dns addresses.
transport = "tor"

# Spin up and use a built-in Tor instance. This only works on macos/linux and you must comment out tor_control_address below.
# This requires that the base node was built with the optional "libtor" feature flag.
#use_libtor = true

# Address of the tor control server
tor_control_address = "/ip4/127.0.0.1/tcp/9051"

# Authentication to use for the tor control server
#tor_control_auth = "none" # or "password=xxxxxx"
# The onion port to use.
#tor_onion_port = 18141
# The address to which traffic on the node's onion address will be forwarded
# tor_forward_address = "/ip4/127.0.0.1/tcp/0"
# Instead of attemping to get the SOCKS5 address from the tor control port, use this one. The default is to
# use the first address returned by the tor control port (GETINFO /net/listeners/socks).
#tor_socks_address_override=

# Use a SOCKS5 proxy transport. This transport recognises any addresses supported by the proxy.
#transport = "socks5"
# The address of the SOCKS5 proxy
# socks5_proxy_address = "/ip4/127.0.0.1/tcp/9050"
# The address to which traffic will be forwarded
#socks5_listener_address = "/ip4/127.0.0.1/tcp/18189"
#socks5_auth = "none" # or "username_password=username:xxxxxxx"

# A path to the file that stores the tor hidden service private key, if using the tor transport.
base_node_tor_identity_file = "config/base_node_tor.json"

# Optionally bind an additional TCP socket for inbound Tari P2P protocol commms.
# Use cases include:
# - allowing wallets to locally connect to their base node, rather than through tor, when used in conjunction with `tor_proxy_bypass_addresses`
# - multiple P2P addresses, one public over DNS and one private over TOR
# - a "bridge" between TOR and TCP-only nodes
# auxilary_tcp_listener_address = "/ip4/127.0.0.1/tcp/9998"

# When these addresses are encountered when dialing another peer, the tor proxy is bypassed and the connection is made
# direcly over TCP. /ip4, /ip6, /dns, /dns4 and /dns6 are supported.
# tor_proxy_bypass_addresses = ["/dns4/my-foo-base-node/tcp/9998"]
# When using the tor transport and set to true, outbound TCP connections bypass the tor proxy. Defaults to false for better privacy
# tor_proxy_bypass_for_outbound_tcp = false

# Configuration options for testnet Igor
[base_node.igor]
# The type of database backend to use. Currently supported options are "memory" and "lmdb". LMDB is recommnded for
# almost all use cases.
db_type = "lmdb"

# db config defaults
# db_init_size_mb = 1000
# db_grow_size_mb = 500
# db_resize_threshold_mb = 100

# The maximum number of orphans that can be stored in the Orphan block pool. Default value is "720".
#orphan_storage_capacity = 720
# The size that the orphan pool will be allowed to grow before it is cleaned out, with threshold being tested every
# time before fetch and add blocks. Default value is "0", which indicates the orphan pool will not be cleaned out.
#orphan_db_clean_out_threshold = 0
# The pruning horizon that indicates how many full blocks without pruning must be kept by the base node. Default value
# is "0", which indicates an archival node without any pruning.
#pruning_horizon = 0

# The amount of messages that will be permitted in the flood ban timespan of 100s (Default igor = 100000,
# default mainnet = 100000)
flood_ban_max_msg_count = 100_000

# The relative path to store persistent data
data_dir = "igor"

# This allowlist provides a method to force syncing from any known nodes you may choose, for example if you have a
# couple of nodes that you always want to have in sync.
# force_sync_peers = ["public_key1::address1", "public_key2::address2",... ]
force_sync_peers = [
    #my known peer 1
    #"public_key1::address1",
    #my known peer 2
    #"public_key1::address1",
]

# Determines the method of syncing blocks when the node is lagging. If you are not struggling with syncing, then
# it is recommended to leave this setting as it. Available values are ViaBestChainMetadata and ViaRandomPeer.
#block_sync_strategy="ViaBestChainMetadata"

# Configure the maximum number of threads available for base node operation. These threads are spawned lazily, so a higher
# number is recommended.
# max_threads = 512

# The number of threads to spawn and keep active at all times. The default is the number of cores available on this node.
# core_threads = <number of cores>

# The node's publicly-accessible hostname. This is the host name that is advertised on the network so that
# peers can find you.
# _NOTE_: If using the `tor` transport type, public_address will be ignored and an onion address will be
# automatically configured
#public_address = "/ip4/172.2.3.4/tcp/18189"

# do we allow test addresses to be accpted like 127.0.0.1
allow_test_addresses = false

# Enable the gRPC server for the base node. Set this to true if you want to enable third-party wallet software
grpc_enabled = true
# The socket to expose for the gRPC base node server. This value is ignored if grpc_enabled is false.
# Valid values here are IPv4 and IPv6 TCP sockets, local unix sockets (e.g. "ipc://base-node-gprc.sock.100")
grpc_base_node_address = "127.0.0.1:18142"

# A path to the file that stores your node identity and secret key
base_node_identity_file = "config/base_node_id.json"

# A path to the file that stores your console wallet's node identity and secret key
console_wallet_identity_file = "config/console_wallet_id.json"

# -------------- Transport configuration --------------
# Use TCP to connect to the Tari network. This transport can only communicate with TCP/IP addresses, so peers with
# e.g. tor onion addresses will not be contactable.
#transport = "tcp"
# The address and port to listen for peer connections over TCP.
#tcp_listener_address = "/ip4/0.0.0.0/tcp/18189"
# Configures a tor proxy used to connect to onion addresses. All other traffic uses direct TCP connections.
# This setting is optional however, if it is not specified, this node will not be able to connect to nodes that
# only advertise an onion address.
#tcp_tor_socks_address = "/ip4/127.0.0.1/tcp/36050"
#tcp_tor_socks_auth = "none"

# Configures the node to run over a tor hidden service using the Tor proxy. This transport recognises ip/tcp,
# onion v2, onion v3 and dns addresses.
transport = "tor"

# Spin up and use a built-in Tor instance. This only works on macos/linux and you must comment out tor_control_address below.
# This requires that the base node was built with the optional "libtor" feature flag.
#use_libtor = true

# Address of the tor control server
tor_control_address = "/ip4/127.0.0.1/tcp/9051"
# Authentication to use for the tor control server
#tor_control_auth = "none" # or "password=xxxxxx"
# The onion port to use.
#tor_onion_port = 18141
# The address to which traffic on the node's onion address will be forwarded
# tor_forward_address = "/ip4/127.0.0.1/tcp/0"
# Instead of attemping to get the SOCKS5 address from the tor control port, use this one. The default is to
# use the first address returned by the tor control port (GETINFO /net/listeners/socks).
#tor_socks_address_override=

# Use a SOCKS5 proxy transport. This transport recognises any addresses supported by the proxy.
#transport = "socks5"
# The address of the SOCKS5 proxy
#socks5_proxy_address = "/ip4/127.0.0.1/tcp/9050"
# The address to which traffic will be forwarded
#socks5_listener_address = "/ip4/127.0.0.1/tcp/18189"
#socks5_auth = "none" # or "username_password=username:xxxxxxx"

# A path to the file that stores the tor hidden service private key, if using the tor transport.
base_node_tor_identity_file = "config/base_node_tor.json"

# Optionally bind an additional TCP socket for inbound Tari P2P protocol commms.
# Use cases include:
# - allowing wallets to locally connect to their base node, rather than through tor, when used in conjunction with `tor_proxy_bypass_addresses`
# - multiple P2P addresses, one public over DNS and one private over TOR
# - a "bridge" between TOR and TCP-only nodes
# auxilary_tcp_listener_address = "/ip4/127.0.0.1/tcp/9998"

# When these addresses are encountered when dialing another peer, the tor proxy is bypassed and the connection is made
# direcly over TCP. /ip4, /ip6, /dns, /dns4 and /dns6 are supported.
# tor_proxy_bypass_addresses = ["/dns4/my-foo-base-node/tcp/9998"]
# When using the tor transport and set to true, outbound TCP connections bypass the tor proxy. Defaults to false for better privacy
# tor_proxy_bypass_for_outbound_tcp = false

[metrics]
# server_bind_address = ...
# push_endpoint = http://localhost:9091/metrics/job/base-node
